
/* Copyright (c) 2010-2014, Peter Barrett
 **
 ** Permission to use, copy, modify, and/or distribute this software for
 ** any purpose with or without fee is hereby granted, provided that the
 ** above copyright notice and this permission notice appear in all copies.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 ** WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 ** WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR
 ** BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES
 ** OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
 ** WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 ** ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 ** SOFTWARE.
 */

#include <Arduino.h>
#include "ztypes.h"

//==========================================================
//==========================================================
//  Webtv keyboard

#define BAUDB   12  // Width of uart bit in HSYNCH
#define PREAMBLE(_t) (_t >= 36 && _t <= 40) // 3.25 baud
#define SHORTBIT(_t) (_t >= 9 && _t <= 13)     // 1.5ms ish

#define MAX_KEY_REPEAT 8         // ~130ms in vbi
extern uint8_t v_vbicountdown;   // Some of these keyboards seem to have a very fast key repeat

uint8_t readKey();
void keyboardIREvent(uint8_t t, uint8_t v); // t is HSYNCH ticks, v is value

// missing some keys, plenty for zork
__attribute__((section(".progmem.data")))
const prog_char _keymap[]  =
{
  // keys
  0x00,0x00,0x62,0x00,0x00,0x1D,0x00,0x00,0x00,0x1E,0x00,0x2F,0x00,0x1F,0x20,0x6E,
  0x60,0x00,0x35,0x00,0x00,0x00,0x00,0x3D,0x00,0x00,0x00,0x2D,0x00,0x00,0x00,0x36,
  0x00,0x00,0x76,0x2E,0x63,0x00,0x00,0x2C,0x78,0x00,0x00,0x00,0x7A,0x00,0x0A,0x6D,
  0x00,0x00,0x66,0x6C,0x64,0x00,0x00,0x6B,0x73,0x00,0x00,0x3B,0x61,0x00,0x5C,0x6A,
  0x00,0x00,0x74,0x00,0x00,0x00,0x00,0x5D,0x00,0x00,0x00,0x5B,0x09,0x00,0x08,0x79,
  0x00,0x00,0x34,0x39,0x33,0x00,0x00,0x38,0x32,0x00,0x00,0x30,0x31,0x00,0x00,0x37,
  0x00,0x00,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x27,0x00,0x00,0x00,0x68,
  0x00,0x00,0x72,0x6F,0x65,0x00,0x00,0x69,0x77,0x00,0x00,0x70,0x71,0x00,0x00,0x75,
  // shifted
  0x00,0x00,0x42,0x00,0x00,0x1D,0x00,0x00,0x00,0x1E,0x00,0x3F,0x00,0x1F,0x20,0x4E,
  0x7E,0x00,0x25,0x00,0x00,0x00,0x00,0x2B,0x00,0x00,0x00,0x5F,0x00,0x00,0x00,0x5E,
  0x00,0x00,0x56,0x3E,0x43,0x00,0x00,0x3C,0x58,0x00,0x00,0x00,0x5A,0x00,0x0A,0x4D,
  0x00,0x00,0x46,0x4C,0x44,0x00,0x00,0x4B,0x53,0x00,0x00,0x3A,0x41,0x00,0x7C,0x4A,
  0x00,0x00,0x54,0x00,0x00,0x00,0x00,0x7D,0x00,0x00,0x00,0x7B,0x09,0x00,0x08,0x59,
  0x00,0x00,0x24,0x28,0x23,0x00,0x00,0x2A,0x40,0x00,0x00,0x29,0x21,0x00,0x00,0x26,
  0x00,0x00,0x47,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x00,0x22,0x00,0x00,0x00,0x48,
  0x00,0x00,0x52,0x4F,0x45,0x00,0x00,0x49,0x57,0x00,0x00,0x50,0x51,0x00,0x00,0x55,
};

#define KEYDOWN     0x4A
#define KEYUP       0x5E
#define SHIFT_LEFT  0x8C
#define SHIFT_RIGHT 0x4C

uint8_t _state = 0;
uint8_t _modifiers = 0;
uint8_t _keyDown = 0;
uint8_t _keyDownLast = 0;
uint8_t _keyUp = 0;
uint16_t _code = 0;

// 
uint8_t ps2_read_key();

uint8_t readKey()
{
  uint8_t k;
  k = ps2_read_key();
  if (k)
    return k;
    
  k = _keyUp;
  if (k) {
    _keyUp = 0;
    switch (k) {
      case SHIFT_LEFT:
      case SHIFT_RIGHT:
        _modifiers &= ~0x80;
        break;
    }
  }
  
  k = _keyDown;
  if (k)
  {
    _keyDown = 0;
    _keyDownLast = k;
    switch (k) {
      case SHIFT_LEFT:
      case SHIFT_RIGHT:
        _modifiers |= 0x80;
        return 0;
    }
    // Check Parity
    uint8_t c;
    uint8_t v = k;
    for (c = 0; v; c++)
      v &= v-1;
    if (c & 1)
    {
      k = pgm_read_byte(_keymap + _modifiers + (((uint8_t)k) >> 1));
      return k;
    }
  }
  return 0;
}

// WebTV UART like keyboard protocol
// 3.25 bit 0 start preamble the 19 bits
// 10 bit code for keyup,keydown, all keys released etc
// 8 bit keycode
// parity bit.
void keyboardIREvent(uint8_t t, uint8_t v)
{
  if (_state == 0)
  {
    if (PREAMBLE(t) && (v == 0))  // long 0, rising edge of start bit
      _state = 1;
  }
  else if (_state == 1)
  {
    _state = (SHORTBIT(t) && (v == 1)) ? 2 : 0;
  }
  else 
  {
      t += BAUDB>>1;
      uint8_t bits = _state-2;
      while ((t > BAUDB) && (bits < 16))
      {
          t -= BAUDB;
          _code = (_code << 1) | v;
          bits++;
      }
      if (bits == 16)
      {
        v = t <= BAUDB;
        uint8_t md = _code >> 8;
        _code |= v;   // Low bit is parity
        if (md == KEYDOWN)
        {
          if ((_keyDownLast != (uint8_t)_code) || (v_vbicountdown == 0)) // Limit key repeat rate
          {
            _keyDown = _code;
            v_vbicountdown = MAX_KEY_REPEAT;
          } else {
            v_vbicountdown = 0;
          }
        }
        else if (md == KEYUP)
        {
          _keyUp = _code;
        }
        _state = 0;
        return;
      }
      _state = bits+2;
    }
}
